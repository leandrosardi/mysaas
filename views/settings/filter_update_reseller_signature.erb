<%
	p_sender_name = params[:sender_name].to_s.empty? ? '' : params[:sender_name]
	p_sender_email = params[:sender_email].to_s.empty? ? '' : params[:sender_email]
	p_sender_contact_user = params[:sender_contact_user].to_s.empty? ? '' : params[:sender_contact_user]

	id_client = params[:id_client]
	allowed = params[:allowed]
	sender_name = URI.unescape(p_sender_name)
	sender_email = URI.unescape(p_sender_email)
	sender_contact_user = URI.unescape(p_sender_contact_user)
	id = ""
	
	if id_client.nil? || id_client.to_s.size == 0
		DB.disconnect
		GC.start
		redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?errdesc=Client%20parameter%20expected."
	else
		c = BlackStack::Client.where(:id => id_client).first
	end

	if allowed.nil? || allowed == 0 || allowed == false || allowed == 'off'
		if c.nil? || c.to_s.size == 0
			DB.disconnect
			GC.start
			redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?errdesc=Client%20parameter%20expected."
		else
			c.domain_for_ssm = nil
			c.from_email_for_ssm = nil
			c.from_name_for_ssm  = nil
			c.domain_for_ssm_verified = nil
			c.id_user_to_contact = nil
			c.save	
		end

		DB.disconnect
		GC.start
		redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?msg=Information%20Updated"
	else
		if sender_name.nil? || sender_name.to_s.size == 0
			DB.disconnect
			GC.start
			redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?errdesc=Sender%20Name%20parameter%20expected."
		end

		if sender_email.nil? || sender_email.to_s.size == 0
			DB.disconnect
			GC.start
			redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?errdesc=Sender%20Email%20parameter%20expected."
		end

		if sender_name.to_s.size > 50 
			DB.disconnect
			GC.start
			redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?errdesc=Sender%20Name%20too%20long."
		end

		if sender_email.to_s.size > 50
			DB.disconnect
			GC.start
			redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?errdesc=Sender%20Email%20too%20long."
		end

		if !BlackStack::Append.verifyDataFormat(BlackStack::Append::TYPE_EMAIL, sender_email)
			DB.disconnect
			GC.start
			redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?errdesc=Sender%20Email%20wrong%20format."
		end

		if p_sender_contact_user.to_s.size == 0
			DB.disconnect
			GC.start
			redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?errdesc=Sender%20Contact%20User%20parameter%20expected."
		end

		if !p_sender_contact_user.guid?
			DB.disconnect
			GC.start
			redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?errdesc=Sender%20Contact%20User%20wrong%20format."
		end
	

		domain = BlackStack::Netting::getDomainFromUrl(sender_email)

		begin
			client_postmark = Postmark::AccountApiClient.new(POSTMARK_API_TOKEN, secure: true, http_ssl_version: :TLSv1_2)
		rescue => exception
			DB.disconnect
			GC.start
			redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?errdesc=#{URI.encode(exception.message)}"
		end

		begin
			client_postmark.create_sender(name: sender_name, from_email: sender_email)	

			c.domain_for_ssm = domain
			c.from_email_for_ssm = sender_email
			c.from_name_for_ssm  = sender_name
			c.id_user_to_contact = p_sender_contact_user
			c.domain_for_ssm_verified = 0
			c.save	

			DB.disconnect
			GC.start
			redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?msg=Information%20Update"	
		rescue Postmark::ApiInputError => exception
			if exception.message == "This Sender Signature already exists."

				signs = client_postmark.get_signatures
				id = ''
=begin
puts
puts "sender_email:#{sender_email}"
				signs.each do |sign|
puts "sign[:email_address]:#{sign[:email_address]}"
					if sign[:email_address] == sender_email
						id = sign[:id]
					end
				end
=end
				# get signature
				# more info: https://github.com/wildbit/postmark-gem/wiki/Senders
				#
				# TODO: this first strategy is not scalable if we handle a large list of signatures.
				# sign = client_postmark.signatures.select { |sign| sign[:domain]==domain }.first
				# 
				# this other approach is a bit more scalable, but anyway we need to call the API 
				# with filering by the domain.
				# 
				# TODO: this code is a replication from the method BlackStack::Client.checkDomainForSSMVerified
				# Refer this issue for more information: https://github.com/leandrosardi/blackstack/issues/95
				#
				pagesize = 30 # TODO: increase this value to 300 for optimization
				i = 0
				j = 1
				sign = nil
				while j>0 && sign.nil?
					buff = client_postmark.get_signatures(offset: i, count: pagesize)
					j = buff.size
					i += pagesize
					sign = buff.select { |s| s[:email_address]==sender_email }.first
				end # while
				id = sign[:id] if !sign.nil?

				s = client_postmark.get_sender(id)
				if s[:confirmed]
					c.domain_for_ssm_verified == 1
				else
					c.domain_for_ssm_verified == 0
				end

				c.domain_for_ssm = domain
				c.from_email_for_ssm = sender_email
				c.from_name_for_ssm  = sender_name
				c.id_user_to_contact = p_sender_contact_user
				c.save	
			
				DB.disconnect
				GC.start
				redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?msg=Information%20Update"
			else
				DB.disconnect
				GC.start
				redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?errdesc=#{URI.encode(exception.message)}"	
			end
		rescue => exception
			DB.disconnect
			GC.start
			redirect_adapted_to_nginx getDivisionURL + "/settings/clientinformation?errdesc=#{URI.encode(exception.message)}"
		end
	end
%>
