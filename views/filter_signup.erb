<% 
redirect = session['redirect_after_login_or_signup']
redirect_on_error = params[:'redirect_on_error']

companyname = params[:companyname]
username = params[:username]
email = params[:email]
password = params[:password]
phone = params[:phone]
a = nil
u = nil
division = nil
userDivision = nil
login = nil

# default values
redirect_on_error = "/signup" if redirect_on_error.to_s.size == 0
redirect = "/dashboard" if redirect.to_s.size == 0

# actualizar las variables de sesion
if companyname.to_s.size>0
	session['companyname'] = companyname.to_s
else
	session['companyname'] = ""
end

if username.to_s.size>0
	session['username'] = username.to_s
else
	session['username'] = ""
end

if email.to_s.size>0
	session['email'] = email.to_s
else
	session['email'] = ""
end

if phone.to_s.size>0
	session['phone'] = phone.to_s
else
	session['phone'] = ""
end

# validar que los parametros no esten vacios
if companyname.to_s.size==0
	# libero recursos
	DB.disconnect	
	GC.start
	#
	redirect "#{redirect_on_error}?err=" + CGI::escape("Company Name is required.")
end

if username.to_s.size==0
	# libero recursos
	DB.disconnect	
	GC.start
	#
	redirect "#{redirect_on_error}?err=" + CGI::escape("Username is required.")
end

if email.to_s.size==0
	# libero recursos
	DB.disconnect	
	GC.start
	#
	redirect "#{redirect_on_error}?err=" + CGI::escape("Email is required.")
end

if password.to_s.size==0
	# libero recursos
	DB.disconnect	
	GC.start
	#
	redirect "#{redirect_on_error}?err=" + CGI::escape("Password is required.")
end

if phone.to_s.size==0
	# libero recursos
	DB.disconnect	
	GC.start
	#
	redirect "#{redirect_on_error}?err=" + CGI::escape("Phone is required.")
end

# validar formato de la password
if !password.password?
	# libero recursos
	DB.disconnect	
	GC.start
	#
	redirect "#{redirect_on_error}?err="+ CGI::escape("Password must be at least 6 characters long.")
end

if !params['email'].email?
	# libero recursos
	DB.disconnect	
	GC.start
	#
	redirect "#{redirect_on_error}?err=" + CGI::escape("Email is not valid.")
end

# comparar contra la base de datos
u = BlackStack::Core::User.where(:email=>email).first

# decidir si el intento de login es exitoso o no
if !u.nil?
	redirect "#{redirect_on_error}?err=" + CGI::escape("Email already exists.")
end

# TODO: Validar formato del email

# TODO: Validar normas de seguridad de la password

# TODO: Validar formato de la password

# getting timezone
t = BlackStack::Core::Timezone.where(:short_description=>DEFAULT_TIMEZONE_SHORT_DESCRIPTION).first
if t.nil?
	redirect "#{redirect_on_error}?err=" + CGI::escape("Default timezone not found.")
end # if t.nil?

DB.transaction do
	# crear el cliente
	a = BlackStack::Core::Account.new
	a.id = guid
	a.id_account_owner = BlackStack::Core::Account.where(:api_key=>BlackStack::Core::API::api_key).first.id # TODO: getting the right owner when we develop domain aliasing
	a.name = companyname
	a.create_time = now
	a.id_timezone = t.id
	a.storage_total_kb = BlackStack::Core::Storage::storage_default_max_allowed_kilobytes
	a.save
	
	# crear el usuario
	u = BlackStack::Core::User.new
	u.id = guid
	u.id_account = a.id
	u.create_time = guid
	u.email = email
	u.name = username
	u.phone = phone
	u.password = password
	u.create_time = now
	u.save
	
	# user owner
	a.id_user_to_contact = u.id
	a.save
	
	# registrar el login
	login = BlackStack::Core::Login.new
	login.id = guid
	login.id_user = u.id
	login.create_time = now
	login.save
		
	# guardar el ID de intento de login en una variable de sesion
	session['login.id'] = login.id 
end # transaction

# blanquo la variable de sesion de redirect
redirect_to = session['redirect_after_login_or_signup'] #"/settings/filter_create_invoice?item_number=SSM.2.Semi-Dedicated-Monthly.2&n=1"
session['redirect_after_login_or_signup'] = nil

# redirect
redirect redirect_to
%>